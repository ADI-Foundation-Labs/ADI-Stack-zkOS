use crypto::MiniDigest;

use crate::bootloader::errors::InvalidTransaction;
use crate::bootloader::transaction::rlp_encoded::rlp::minimal_rlp_parser::Rlp;
use crate::bootloader::transaction::rlp_encoded::transaction_types::legacy_tx::{
    LegacyPayloadParser, LegacySignatureData, LegacyTXInner,
};
use crate::bootloader::transaction::rlp_encoded::transaction_types::EthereumTxType;
use crate::bootloader::transaction::rlp_encoded::{
    eip_2718_tx_envelope::{EIP2718PayloadParser, EIP2718SignatureData},
    transaction_types::eip_1559_tx::EIP1559Tx,
    transaction_types::eip_2930_tx::EIP2930Tx,
    transaction_types::eip_7702_tx::EIP7702Tx,
};
use zk_ee::utils::Bytes32;

mod eip_2718_tx_envelope;
mod rlp;
mod transaction;
mod transaction_types;

pub use self::transaction::RlpEncodedTransaction;
pub use transaction_types::eip_2930_tx::AccessListForAddress;
#[cfg(feature = "pectra")]
pub use transaction_types::eip_7702_tx::{AuthorizationEntry, AuthorizationList};

use super::TxError;

#[derive(Clone, Copy, Debug)]
pub(crate) enum RlpEncodedTxInner<'a> {
    Legacy(LegacyTXInner<'a>, LegacySignatureData<'a>),
    LegacyWithEIP155(LegacyTXInner<'a>, LegacySignatureData<'a>),
    EIP2930(EIP2930Tx<'a>, EIP2718SignatureData<'a>),
    EIP1559(EIP1559Tx<'a>, EIP2718SignatureData<'a>),
    EIP7702(EIP7702Tx<'a>, EIP2718SignatureData<'a>),
}

impl<'a> RlpEncodedTxInner<'a> {
    // NOTE: u64 chain ID allows to avoid handling some overflows below
    pub(crate) fn parse_and_compute_signed_hash(
        input: &'a [u8],
        expected_chain_id: u64,
    ) -> Result<(Self, Bytes32), TxError> {
        // Try to read a leading single-byte item as the typed marker.
        // For typed txs, this is a bare byte (1/2/4) followed by an RLP list.
        let mut r = Rlp::new(input);
        if let Ok(tx_type) = r.u8() {
            match tx_type {
                EIP2930Tx::TX_TYPE => {
                    let (tx, sig_data, sig_hash) =
                        EIP2718PayloadParser::<EIP2930Tx<'a>>::try_parse_and_hash_for_signature_verification(
                            r.remaining()
                        )?;

                    if tx.chain_id != expected_chain_id {
                        return Err(InvalidTransaction::InvalidChainId.into());
                    }
                    Ok((Self::EIP2930(tx, sig_data), sig_hash))
                }
                EIP1559Tx::TX_TYPE => {
                    let (tx, sig_data, sig_hash) =
                        EIP2718PayloadParser::<EIP1559Tx<'a>>::try_parse_and_hash_for_signature_verification(
                            r.remaining()
                        )?;
                    if tx.chain_id != expected_chain_id {
                        return Err(InvalidTransaction::InvalidChainId.into());
                    }
                    Ok((Self::EIP1559(tx, sig_data), sig_hash))
                }
                EIP7702Tx::TX_TYPE => {
                    let (tx, sig_data, sig_hash) =
                        EIP2718PayloadParser::<EIP7702Tx<'a>>::try_parse_and_hash_for_signature_verification(
                            r.remaining()
                        )?;

                    if tx.chain_id != expected_chain_id {
                        return Err(InvalidTransaction::InvalidChainId.into());
                    }
                    Ok((Self::EIP7702(tx, sig_data), sig_hash))
                }
                _ => Err(InvalidTransaction::InvalidEncoding.into()),
            }
        } else {
            // Legacy path
            let (tx, sig_data, sig_hash) =
                LegacyPayloadParser::try_parse_and_hash_for_signature_verification(
                    input,
                    expected_chain_id,
                )?;

            let tx = if sig_data.is_eip155() {
                Self::LegacyWithEIP155(tx, sig_data)
            } else {
                Self::Legacy(tx, sig_data)
            };

            Ok((tx, sig_hash))
        }
    }
}

#[cfg(test)]
mod test {
    use std::alloc::Global;

    use super::*;
    use alloy::consensus::{SignableTransaction, TxEnvelope};
    use alloy_primitives::hex;
    use alloy_rlp::Decodable;
    use ruint::aliases::B160;
    use zk_ee::utils::UsizeAlignedByteBox;

    fn compute_signed_hash_alloy(raw: &[u8]) -> [u8; 32] {
        let mut r = raw;
        let env = TxEnvelope::decode(&mut r).expect("must parse");
        let signing_hash = match env {
            TxEnvelope::Legacy(signed) => signed.tx().signature_hash(),
            TxEnvelope::Eip2930(signed) => signed.tx().signature_hash(),
            TxEnvelope::Eip1559(signed) => signed.tx().signature_hash(),
            TxEnvelope::Eip7702(signed) => signed.tx().signature_hash(),
            _ => unimplemented!(),
        };
        signing_hash.0
    }

    #[test]
    fn test_on_random_legacy() {
        let input = hex::decode("f901ab820215840cc9aa6c82ca9c94bf7cf0d775d6ac130912a22861773c21661095a280b90144baae8abf0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000008f3ffa11cd5915f0e869192663b905504a2ef4a500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000064d22c0930000000000000000000000000953ca96b057d5397ce7791c5ae9b5a19b135234100000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000689010fd0000000000000000000000000000000000000000000000000000000026a005b37d188e6af6851c1036a5c42113ada300c03403d340d4c9ba8102146e9a76a0471b7967f289f3248f4250d0dbcb8e7391ea0b9252385377909911420f164db7").unwrap();
        let alloy_signed_hash = compute_signed_hash_alloy(&input);
        let buffer = UsizeAlignedByteBox::<Global>::from_slice_in(&input, Global);
        let tx = RlpEncodedTransaction::parse_from_buffer(buffer, 1, B160::ZERO).unwrap();
        assert_eq!(
            alloy_signed_hash,
            tx.hash_for_signature_verification().as_u8_array()
        )
    }

    #[test]
    fn test_on_random_2930() {
        let input = hex::decode("01f901730132840cec9a4e8303efad94bcb4e4bcc41ab1494a3eb3456ed4edb8da5d46e4870f0d557cb2c2c1b90104088890dc000000000000000000000000000000000000000000000003ef2218b5b343818b00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000003aa876a9554ca3c8ae01505d463a0c5dd0b0cd4d0000000000000000000000000000000000000000000000000000019872c72f610000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000005959e94661e1203e0c8ef84095a7846bacc6a94fc001a00d23db670f786bc70018f243e301b27891f751505fd15a89e1bba35db8da987ba058fdfbb6099b96ad14794b03205461c465c8fb9389b9590f664865e1146f060a").unwrap();
        let alloy_signed_hash = compute_signed_hash_alloy(&input);
        let buffer = UsizeAlignedByteBox::<Global>::from_slice_in(&input, Global);
        let tx = RlpEncodedTransaction::parse_from_buffer(buffer, 1, B160::ZERO).unwrap();
        assert_eq!(
            alloy_signed_hash,
            tx.hash_for_signature_verification().as_u8_array()
        )
    }

    #[test]
    fn test_on_random_1559() {
        let input = hex::decode("02f90491018201a08207d0840f8d04a083055d579489c6340b1a1f4b25d36cd8b063d49045caf3f81880b90424d7a08473000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000004acfda580000000000000000000000000000000000000000000000000000000068900799000000000000000000000000000000000000000000000000000000000000001b5d84e1c46e8ed13b0f65676700d7680054ea48feab766b141358c191ee71f3b330942381ca0b79e4f9ed50219bcdcc634f175e7dd36342c3fd4ab00f5cd48ea300000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000304ae32859000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000200a800b1f5699b7861686ca5a828d35734c5983d24ac2b0b61d427507d6b3a6965000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000097f41f4802a6147143f66a625343b9039c700ecc000000000000000000000000000000000000000000000000000000004acfda58000000000000000000000000000000000000000000000000000000000000a4b100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000572656c6179000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f6a756d7065722e65786368616e67650000000000000000000000000000000000e7d070ff55ae1dff4f9b398df94abb677aa14ae5996f371202ec928e3c06f25400000000000000000000000097f41f4802a6147143f66a625343b9039c700ecc000000000000000000000000af88d065e77c8cc2239327c5edb3a432268e5831000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000414c20c8c28980012ba9e3e46baad9aca2c0fc539edeb26564f7613ddfb3bb7e57690da91e2650e2088b8d31659cc31ad6063bc6b0c757ac23868e41396858f1a51b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c080a019e4aee5788915a5d72ad38f00384a34be0d197b2557e89b5db6220746fda216a0155f9959cf268f761b218594fb8e4bb1b534df8bbb8d2430b4c7036c59e2f29e").unwrap();
        let alloy_signed_hash = compute_signed_hash_alloy(&input);
        let buffer = UsizeAlignedByteBox::<Global>::from_slice_in(&input, Global);
        let tx = RlpEncodedTransaction::parse_from_buffer(buffer, 1, B160::ZERO).unwrap();
        assert_eq!(
            alloy_signed_hash,
            tx.hash_for_signature_verification().as_u8_array()
        )
    }

    #[test]
    fn test_on_random_7702() {
        let input = hex::decode("04f9077101820d068402faf0808419977a0f8305606c940000000071727de22e5e9d8baf0edac6f37da03280b906a4765e827f0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000fdc043d3e922d392fb396f6cdfa20b864b428280000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000006303ec3b6610715b9584c2ccbec4789f9c56f3540000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000b7980000000000000000000000000000cd2c000000000000000000000000000000000000000000000000000000000001861c000000000000000000000000039387000000000000000000000000001cce824400000000000000000000000000000000000000000000000000000000000004c000000000000000000000000000000000000000000000000000000000000005a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034426da7d8800000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000220000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000007d3201fa7a85c0a5f9fa1c0c6b9d0b784368d2ac000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000044095ea7b30000000000000000000000007d3201fa7a85c0a5f9fa1c0c6b9d0b784368d2ac00000000000000000000000000000000000000000000000000000000000aaa1f00000000000000000000000000000000000000000000000000000000000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000044a9059cbb0000000000000000000000007f4fbc470620d0f91f6e0e6e1bd00a9c8d5786b20000000000000000000000000000000000000000000000000000000004c4b400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b57d3201fa7a85c0a5f9fa1c0c6b9d0b784368d2ac000000000000000000000000000061a800000000000000000000000000005daa000068ecbc9a000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000000000000000000062064d5287c2485c8293cbbb69f9e1906cf6d9359e3ea2585f0bc4a60c3c9eb5575f220a3a543d2d15151b28148e24acb9f72d219b0169d9bd2751026c71c6cccd19c1c000000000000000000000000000000000000000000000000000000000000000000000000000000000000417d0e5794393da57e3fc52409766d31842c0b5f3ed4f94f0f89b0fac71e995a4a32c460981d39621df352686eeaac92818ce8faa0cc9020b2518a5773957b01ab1c00000000000000000000000000000000000000000000000000000000000000c0f85cf85a0194d2e28229f6f2c235e57de2ebc727025a1d0530fb5001a0a30c512336ab49f4715e39c7414df0cd29c587ffb286d08bc03f50dff579a0eda009be7b5f49e806c00ead7b04946b5f505c0a75bbc08a0c0ed2d39728345e6cb780a00bc31d69a5b8ae70cfc8ee52fad5e1e6505a9139965d586c1e5e6871c15ebf5da024064528d690af9bcb999a91bfe25c6797bced894d6be1f4164189fa45e8e8f0").unwrap();
        let alloy_signed_hash = compute_signed_hash_alloy(&input);
        let buffer = UsizeAlignedByteBox::<Global>::from_slice_in(&input, Global);
        let tx = RlpEncodedTransaction::parse_from_buffer(buffer, 1, B160::ZERO).unwrap();
        assert_eq!(
            alloy_signed_hash,
            tx.hash_for_signature_verification().as_u8_array()
        )
    }
}
